CREATE SCHEMA IF NOT EXISTS public;
CREATE SCHEMA
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
CREATE EXTENSION
CREATE TABLE IF NOT EXISTS account(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  id            VARCHAR(100) PRIMARY KEY,
  login         VARCHAR(40)  NOT NULL,
  password      BYTEA        NOT NULL,
  updated_at    TIMESTAMPTZ  DEFAULT now()
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS account_unique_login_idx
  ON account (lower(login));
CREATE INDEX
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_type') THEN
    CREATE TYPE email_type AS ENUM('BACKUP', 'EXTRA', 'PRIMARY');
  END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS email(
  created_at  TIMESTAMPTZ  DEFAULT now(),
  id          VARCHAR(100) PRIMARY KEY,
  type        email_type   DEFAULT 'EXTRA',
  updated_at  TIMESTAMPTZ  DEFAULT now(),
  user_id     VARCHAR(100) NOT NULL,
  value       VARCHAR(40)  NOT NULL,
  verified_at TIMESTAMPTZ,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS email_unique_value_idx
  ON email (lower(value));
CREATE INDEX
CREATE INDEX IF NOT EXISTS email_user_id_idx ON email (user_id);
CREATE INDEX
CREATE UNIQUE INDEX IF NOT EXISTS email_unique_user_id_type_idx
  ON email (user_id, type)
  WHERE type = ANY('{"PRIMARY", "BACKUP"}');
CREATE INDEX
CREATE OR REPLACE FUNCTION email_will_update()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    NEW.updated_at = now();
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'email'
    AND trigger_name = 'before_email_update'
) THEN
  CREATE TRIGGER before_email_update
    BEFORE INSERT ON email
    FOR EACH ROW EXECUTE PROCEDURE email_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_profile(
  bio           TEXT,
  email_id      VARCHAR(100),
  name          TEXT         CHECK(name ~ '^[\w|-][\w|-|\s]+[\w|-]$'),
  updated_at    TIMESTAMPTZ  DEFAULT now(),
  user_id       VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (email_id)
    REFERENCES email (id)
    ON UPDATE NO ACTION ON DELETE NO ACTION,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE OR REPLACE FUNCTION check_user_profile_email_id(_email_id VARCHAR)
  RETURNS VOID
  LANGUAGE plpgsql
AS $$
  DECLARE e RECORD;
  BEGIN
    IF _email_id IS NOT NULL THEN
      SELECT 
        user_id,
        verified_at
      INTO STRICT e
      FROM email
      WHERE id = _email_id;
      IF NOT FOUND THEN
        RAISE EXCEPTION 'email with id `%` not found', _email_id;
      ELSIF e.user_id != OLD.user_id THEN
        RAISE EXCEPTION 'cannot set user_profile.email_id to an email not owned by the user';
      ELSIF e.verified_at IS NULL THEN
        RAISE EXCEPTION 'cannot set user_profile.email_id to an unverified email';
      END IF;
    END IF;
    RETURN;
  END;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION user_profile_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM check_user_profile_email_id(NEW.email_id);
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_profile'
    AND trigger_name = 'before_user_profile_update'
) THEN
  CREATE TRIGGER before_user_profile_update
    BEFORE UPDATE ON user_profile
    FOR EACH ROW EXECUTE PROCEDURE user_profile_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS role(
  created_at  TIMESTAMPTZ DEFAULT now(),
  description TEXT        NOT NULL,
  name        VARCHAR(40) PRIMARY KEY
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS role_unique_upper_name_idx
  ON role (upper(name));
CREATE INDEX
INSERT INTO role(name, description)
VALUES
  ('ADMIN', 'Grants administrative permissions.'),
  ('MEMBER', 'Grants additional permission to users with a membership.'),
  ('OWNER', 'Grants additional permissions to objects owned by the user.'),
  ('USER',  'Grants general user permissions.')
ON CONFLICT (name) DO NOTHING;
INSERT 0 4
CREATE TABLE IF NOT EXISTS user_role(
  created_at  TIMESTAMPTZ   DEFAULT now(),
  role        VARCHAR(40),
  user_id     VARCHAR(100),
  PRIMARY KEY (user_id, role),
  FOREIGN KEY (role)
    REFERENCES role (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE OR REPLACE VIEW user_master AS
SELECT
  account.updated_at account_updated_at,
  user_profile.bio,
  account.created_at,
  account.id,
  account.login,
  user_profile.name,
  user_profile.updated_at profile_updated_at,
  user_profile.email_id profile_email_id,
  ARRAY(
    SELECT role.name
    FROM role
    LEFT JOIN user_role ON user_role.user_id = account.id
    WHERE role.name = user_role.role
  ) roles
FROM account
JOIN user_profile ON user_profile.user_id = account.id;
CREATE VIEW
CREATE OR REPLACE VIEW user_credentials AS
SELECT
  backup_email.value backup_email,
  account.id,
  account.login,
  account.password,
  primary_email.value primary_email,
  ARRAY(
    SELECT role.name
    FROM role
    LEFT JOIN user_role ON user_role.user_id = account.id
    WHERE role.name = user_role.role
  ) roles
FROM account
JOIN email primary_email ON primary_email.user_id = account.id
  AND primary_email.type = 'PRIMARY'
LEFT JOIN email backup_email ON backup_email.user_id = account.id
  AND backup_email.type = 'BACKUP';
CREATE VIEW
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'access_level') THEN
    CREATE TYPE access_level AS ENUM(
      'Read', 'Create', 'Connect', 'Disconnect', 'Update', 'Delete'
    );
  END IF;
END
$$ language 'plpgsql';
DO
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audience') THEN
    CREATE TYPE audience AS ENUM('AUTHENTICATED', 'EVERYONE');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS permission(
  access_level access_level NOT NULL,
  audience     audience     NOT NULL,
  created_at   TIMESTAMPTZ  DEFAULT now(),
  field        TEXT,
  id           VARCHAR(100) PRIMARY KEY,
  type         TEXT         NOT NULL,
  updated_at   TIMESTAMPTZ  DEFAULT now()
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS permission_access_level_type_field_key
  ON permission (access_level, type, field)
  WHERE field IS NOT NULL;
CREATE INDEX
CREATE UNIQUE INDEX IF NOT EXISTS permission_access_level_type_key
  ON permission (access_level, type)
  WHERE field IS NULL;
CREATE INDEX
CREATE OR REPLACE FUNCTION permission_will_update()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    NEW.updated_at = now();
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'permission'
    AND trigger_name = 'before_permission_update'
) THEN
  CREATE TRIGGER before_permission_update
    BEFORE INSERT ON permission
    FOR EACH ROW EXECUTE PROCEDURE permission_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS role_permission(
  created_at    TIMESTAMPTZ   DEFAULT now(),
  permission_id VARCHAR(100),
  role          VARCHAR(40),
  PRIMARY KEY (role, permission_id),
  FOREIGN KEY (role)
    REFERENCES role (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (permission_id)
    REFERENCES permission (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE OR REPLACE VIEW role_permission_master AS
SELECT
  permission.access_level,
  permission.created_at,
  permission.field,
  role_permission.created_at granted_at,
  permission.id,
  role_permission.role,
  permission.type,
  permission.updated_at
FROM permission
JOIN role_permission ON role_permission.permission_id = permission.id;
CREATE VIEW
CREATE TABLE IF NOT EXISTS email_verification_token(
  email_id      VARCHAR(100),
  expires_at    TIMESTAMPTZ   DEFAULT (now() + interval '20 minutes'),
  issued_at     TIMESTAMPTZ   DEFAULT now(),
  token         VARCHAR(40),
  user_id       VARCHAR(100)  NOT NULL,
  verified_at   TIMESTAMPTZ,
  PRIMARY KEY (email_id, token),
  FOREIGN KEY (email_id)
    REFERENCES email (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS email_verification_token_user_id_idx
  ON email_verification_token (user_id); 
CREATE INDEX
CREATE TABLE IF NOT EXISTS password_reset_token(
  email_id      VARCHAR(100)  NOT NULL,
  issued_at     TIMESTAMPTZ   DEFAULT now(),
  end_ip        INET,
  ended_at      TIMESTAMPTZ,
  expires_at    TIMESTAMPTZ   DEFAULT (now() + interval '20 minutes'),
  request_ip    INET          NOT NULL,
  token         VARCHAR(40),
  user_id       VARCHAR(100),
  PRIMARY KEY (user_id, token),
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE NO ACTION,
  FOREIGN KEY (email_id)
    REFERENCES email (id)
    ON UPDATE NO ACTION ON DELETE NO ACTION
);
CREATE TABLE
CREATE TABLE IF NOT EXISTS study(
  advanced_at   TIMESTAMPTZ,
  created_at    TIMESTAMPTZ   DEFAULT now(),
  description   TEXT,
  id            VARCHAR(100)  PRIMARY KEY,
  name          TEXT          NOT NULL CHECK (name ~ '[\w|-]+'),
  name_tokens   TEXT          NOT NULL,
  private       BOOLEAN       DEFAULT FALSE,
  updated_at    TIMESTAMPTZ   DEFAULT now(),
  user_id       VARCHAR(100)  NOT NULL,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS study_unique_user_id_name_key
  ON study (user_id, lower(name));
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_user_id_advanced_at_idx
  ON study (user_id, advanced_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_user_id_updated_at_idx
  ON study (user_id, updated_at);
CREATE INDEX
CREATE OR REPLACE FUNCTION study_will_update()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    NEW.updated_at = now();
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'study'
    AND trigger_name = 'before_study_update'
) THEN
  CREATE TRIGGER before_study_update
    BEFORE INSERT ON study
    FOR EACH ROW EXECUTE PROCEDURE study_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION advance_study(_study_id VARCHAR)
  RETURNS VOID
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE study
  SET advanced_at = now()
  WHERE study.id = _study_id;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS lesson(
  created_at      TIMESTAMPTZ  DEFAULT now(),
  body            TEXT,
  id              VARCHAR(100) PRIMARY KEY,
  number          INT          NOT NULL CHECK(number > 0),
  published_at    TIMESTAMPTZ,
  study_id        VARCHAR(100) NOT NULL,    
  title           TEXT         NOT NULL,
  title_tokens    TEXT         NOT NULL,
  updated_at      TIMESTAMPTZ  DEFAULT now(),
  user_id         VARCHAR(100) NOT NULL,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS lesson_study_id_number_idx
  ON lesson (study_id, number);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_user_id_idx
  ON lesson (user_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION lesson_will_insert()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  SELECT INTO NEW.number count(*)::INT
  FROM lesson
  WHERE study_id = NEW.study_id;
  NEW.number = NEW.number + 1;
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson'
    AND trigger_name = 'before_lesson_insert'
) THEN
  CREATE TRIGGER before_lesson_insert
    BEFORE INSERT ON lesson
    FOR EACH ROW EXECUTE PROCEDURE lesson_will_insert(); 
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION lesson_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson'
    AND trigger_name = 'before_lesson_update'
) THEN
  CREATE TRIGGER before_lesson_update
    BEFORE UPDATE ON lesson
    FOR EACH ROW EXECUTE PROCEDURE lesson_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'course_status') THEN
    CREATE TYPE course_status AS ENUM('ADVANCING', 'COMPLETED');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS course(
  advanced_at   TIMESTAMPTZ,
  completed_at  TIMESTAMPTZ,
  created_at    TIMESTAMPTZ   DEFAULT now(),
  description   TEXT,
  id            VARCHAR(100)  PRIMARY KEY,
  name          TEXT          NOT NULL CHECK (name ~ '[\w|-]+'),
  name_tokens   TEXT          NOT NULL,
  number        INT           CHECK(number > 0),
  status        course_status DEFAULT 'ADVANCING',
  study_id      VARCHAR(100)  NOT NULL,
  updated_at    TIMESTAMPTZ   DEFAULT now(),
  user_id       VARCHAR(100)  NOT NULL,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS course_unique_study_id_name_key
  ON course (study_id, lower(name));
CREATE INDEX
CREATE UNIQUE INDEX IF NOT EXISTS course_study_id_number_idx
  ON course (study_id, number);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_study_id_created_at_idx
  ON course (study_id, created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_study_id_advanced_at_idx
  ON course (study_id, advanced_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_user_id_idx
  ON course (user_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION course_will_insert()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  SELECT INTO NEW.number count(*)::INT
  FROM course
  WHERE study_id = NEW.study_id;
  NEW.number = NEW.number + 1;
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course'
    AND trigger_name = 'before_course_insert'
) THEN
  CREATE TRIGGER before_course_insert
    BEFORE INSERT ON course
    FOR EACH ROW EXECUTE PROCEDURE course_will_insert(); 
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION course_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course'
    AND trigger_name = 'before_course_update'
) THEN
  CREATE TRIGGER before_course_update
    BEFORE UPDATE ON course
    FOR EACH ROW EXECUTE PROCEDURE course_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION advance_course(_course_id VARCHAR)
  RETURNS VOID
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE course
  SET advanced_at = now()
  WHERE course.id = _course_id;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS course_lesson(
  created_at      TIMESTAMPTZ  DEFAULT now(),
  course_id       VARCHAR(100) NOT NULL,
  lesson_id       VARCHAR(100) PRIMARY KEY,
  number          INT          NOT NULL CHECK(number > 0),
  FOREIGN KEY (course_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (lesson_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS course_lesson_course_id_number_unique_idx
  ON course_lesson (course_id, number);
CREATE INDEX
CREATE OR REPLACE FUNCTION course_lesson_will_insert()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  SELECT INTO NEW.number count(*)::INT
  FROM course_lesson
  WHERE course_id = NEW.course_id;
  NEW.number = NEW.number + 1;

  UPDATE course_lesson
  SET number = number + 1
  WHERE course_id = NEW.course_id AND number >= NEW.number;

  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course_lesson'
    AND trigger_name = 'before_course_lesson_insert'
) THEN
  CREATE TRIGGER before_course_lesson_insert
    BEFORE INSERT ON course_lesson
    FOR EACH ROW EXECUTE PROCEDURE course_lesson_will_insert(); 
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW lesson_master AS
SELECT
  lesson.body,
  lesson.created_at,
  course_lesson.course_id,
  course_lesson.number course_number,
  lesson.id,
  lesson.number,
  lesson.published_at,
  lesson.study_id,
  lesson.title,
  lesson.updated_at,
  lesson.user_id
FROM lesson
LEFT JOIN course_lesson ON course_lesson.lesson_id = lesson.id;
CREATE VIEW
CREATE TABLE IF NOT EXISTS lesson_comment(
  body            TEXT,
  created_at      TIMESTAMPTZ  DEFAULT now(),
  id              VARCHAR(100) PRIMARY KEY,
  lesson_id       VARCHAR(100) NOT NULL,
  published_at    TIMESTAMPTZ,
  study_id        VARCHAR(100) NOT NULL,
  user_id         VARCHAR(100) NOT NULL,
  updated_at      TIMESTAMPTZ  DEFAULT now(),
  FOREIGN KEY (lesson_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS lesson_comment_user_id_idx
  ON lesson_comment (user_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_comment_study_id_idx
  ON lesson_comment (study_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_comment_lesson_id_created_at_idx
  ON lesson_comment (lesson_id, created_at);
CREATE INDEX
CREATE OR REPLACE FUNCTION lesson_comment_will_insert()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.study_id IS NULL THEN
    SELECT study.id
    INTO NEW.study_id
    FROM study
    JOIN lesson ON lesson.id = NEW.lesson_id
    WHERE study.id = lesson.study_id;
  END IF;
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_comment'
    AND trigger_name = 'before_lesson_comment_insert'
) THEN
  CREATE TRIGGER before_lesson_comment_insert
    BEFORE INSERT ON lesson_comment
    FOR EACH ROW EXECUTE PROCEDURE lesson_comment_will_insert();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION lesson_comment_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_comment'
    AND trigger_name = 'before_lesson_comment_update'
) THEN
  CREATE TRIGGER before_lesson_comment_update
    BEFORE UPDATE ON lesson_comment
    FOR EACH ROW EXECUTE PROCEDURE lesson_comment_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS label(
  color       TEXT         NOT NULL,
  created_at  TIMESTAMPTZ  DEFAULT now(),
  description TEXT,
  id          VARCHAR(100) PRIMARY KEY,
  is_default  BOOLEAN      DEFAULT FALSE,
  name        VARCHAR(40)  NOT NULL,
  name_tokens TEXT         NOT NULL,
  study_id    VARCHAR(100) NOT NULL,
  updated_at  TIMESTAMPTZ  DEFAULT now()
); 
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS label_unique_study_id_name_idx
  ON label (study_id, lower(name));
CREATE INDEX
CREATE OR REPLACE FUNCTION label_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'label'
    AND trigger_name = 'before_label_update'
) THEN
  CREATE TRIGGER before_label_update
    BEFORE UPDATE ON label
    FOR EACH ROW EXECUTE PROCEDURE label_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS labeled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  id            SERIAL       PRIMARY KEY,
  label_id      VARCHAR(100) NOT NULL,
  labelable_id  VARCHAR(100) NOT NULL,
  FOREIGN KEY (label_id)
    REFERENCES label (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS labeled_unique_labelable_id_label_id_idx
  ON labeled (labelable_id, label_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION insert_labeled()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE new_labeled_id TEXT;
  BEGIN
    INSERT INTO labeled(label_id, labelable_id)
    VALUES (NEW.label_id, NEW.labelable_id)
    ON CONFLICT (labelable_id, label_id) DO NOTHING
    RETURNING id INTO new_labeled_id;
    IF new_labeled_id IS NULL THEN
      RETURN NULL;
    END IF;
    NEW.labeled_id = new_labeled_id;
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS lesson_labeled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  label_id      VARCHAR(100),
  labelable_id  VARCHAR(100),
  labeled_id    INT          PRIMARY KEY,
  FOREIGN KEY (label_id)
    REFERENCES label (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (labeled_id)
    REFERENCES labeled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (labelable_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS lesson_labeled_label_id_labelable_id_idx
  ON lesson_labeled (label_id, labelable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'lesson_labeled'
    AND trigger_name = 'before_lesson_labeled_insert'
) THEN
  CREATE TRIGGER before_lesson_labeled_insert
    BEFORE INSERT ON lesson_labeled
    FOR EACH ROW EXECUTE PROCEDURE insert_labeled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_comment_labeled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  label_id      VARCHAR(100),
  labelable_id  VARCHAR(100),
  labeled_id    INT          PRIMARY KEY,
  FOREIGN KEY (label_id)
    REFERENCES label (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (labeled_id)
    REFERENCES labeled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (labelable_id)
    REFERENCES lesson_comment (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS lesson_comment_labeled_label_id_labelable_id_idx
  ON lesson_comment_labeled (label_id, labelable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'lesson_comment_labeled'
    AND trigger_name = 'before_lesson_comment_labeled_insert'
) THEN
  CREATE TRIGGER before_lesson_comment_labeled_insert
    BEFORE INSERT ON lesson_comment_labeled
    FOR EACH ROW EXECUTE PROCEDURE insert_labeled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW label_search_index AS
SELECT
  label.*,
  (count(lesson_labeled) + count(lesson_comment_labeled)) labeled_count,
  setweight(to_tsvector('simple', name_tokens), 'A') AS document
FROM label
LEFT JOIN lesson_labeled ON lesson_labeled.label_id = label.id
LEFT JOIN lesson_comment_labeled ON lesson_comment_labeled.label_id = label.id
GROUP BY label.id;
CREATE VIEW
CREATE OR REPLACE VIEW labelable_label AS
SELECT
  label.color,
  label.created_at,
  label.description,
  label.id,
  label.is_default,
  labeled.labelable_id,
  labeled.created_at labeled_at,
  label.name,
  label.study_id,
  label.updated_at
FROM label
JOIN labeled ON labeled.label_id = label.id;
CREATE VIEW
CREATE OR REPLACE VIEW labeled_lesson AS
SELECT
  lesson_master.*,
  lesson_labeled.label_id,
  lesson_labeled.created_at labeled_at
FROM lesson_master
JOIN lesson_labeled ON lesson_labeled.labelable_id = lesson_master.id;
CREATE VIEW
CREATE OR REPLACE VIEW labeled_lesson_comment AS
SELECT
  lesson_comment.body,
  lesson_comment.created_at,
  lesson_comment.id,
  lesson_comment_labeled.label_id,
  lesson_comment_labeled.created_at labeled_at,
  lesson_comment.lesson_id,
  lesson_comment.published_at,
  lesson_comment.study_id,
  lesson_comment.updated_at,
  lesson_comment.user_id
FROM lesson_comment
JOIN lesson_comment_labeled ON lesson_comment_labeled.labelable_id = lesson_comment.id;
CREATE VIEW
CREATE TABLE IF NOT EXISTS topic(
  created_at  TIMESTAMPTZ  DEFAULT now(),
  description TEXT,
  id          VARCHAR(100) PRIMARY KEY,
  name        VARCHAR(40)  NOT NULL CHECK(name ~ '^[a-zA-Z0-9][a-zA-Z0-9|-]+[a-zA-Z0-9]$'),
  name_tokens TEXT         NOT NULL,
  updated_at  TIMESTAMPTZ  DEFAULT now()
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS topic_unique_name_idx
  ON topic (lower(name));
CREATE INDEX
CREATE OR REPLACE FUNCTION topic_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'topic'
    AND trigger_name = 'before_topic_update'
) THEN
  CREATE TRIGGER before_topic_update
    BEFORE UPDATE ON topic
    FOR EACH ROW EXECUTE PROCEDURE topic_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS topiced(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  id            SERIAL       PRIMARY KEY,
  topic_id      VARCHAR(100) NOT NULL,
  topicable_id  VARCHAR(100) NOT NULL,
  FOREIGN KEY (topic_id)
    REFERENCES topic (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS topiced_unique_topicable_id_topic_id_idx
  ON topiced (topicable_id, topic_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION insert_topiced()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
DECLARE new_topiced_id TEXT;
BEGIN
  INSERT INTO topiced(topic_id, topicable_id)
  VALUES (NEW.topic_id, NEW.topicable_id)
  ON CONFLICT (topicable_id, topic_id) DO NOTHING
  RETURNING id INTO new_topiced_id;
  IF new_topiced_id IS NULL THEN
    RETURN NULL;
  END IF;
  NEW.topiced_id = new_topiced_id;
  RETURN NEW;
END;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS course_topiced(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  topic_id      VARCHAR(100),
  topicable_id  VARCHAR(100),
  topiced_id    INT          PRIMARY KEY,
  FOREIGN KEY (topic_id)
    REFERENCES topic (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (topiced_id)
    REFERENCES topiced (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (topicable_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS course_topiced_topic_id_topicable_id_idx
  ON course_topiced (topic_id, topicable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'course_topiced'
    AND trigger_name = 'before_course_topiced_insert'
) THEN
  CREATE TRIGGER before_course_topiced_insert
    BEFORE INSERT ON course_topiced
    FOR EACH ROW EXECUTE PROCEDURE insert_topiced();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS study_topiced(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  topic_id      VARCHAR(100),
  topicable_id  VARCHAR(100),
  topiced_id    INT          PRIMARY KEY,
  FOREIGN KEY (topic_id)
    REFERENCES topic (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (topiced_id)
    REFERENCES topiced (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (topicable_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS study_topiced_topic_id_topicable_id_idx
  ON study_topiced (topic_id, topicable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'study_topiced'
    AND trigger_name = 'before_study_topiced_insert'
) THEN
  CREATE TRIGGER before_study_topiced_insert
    BEFORE INSERT ON study_topiced
    FOR EACH ROW EXECUTE PROCEDURE insert_topiced();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW topicable_topic AS
SELECT
  topic.created_at,
  topic.description,
  topic.id,
  topic.name,
  topiced.topicable_id,
  topiced.created_at topiced_at,
  topic.updated_at
FROM topic
JOIN topiced ON topiced.topic_id = topic.id;
CREATE VIEW
CREATE OR REPLACE VIEW topiced_course AS
SELECT
  course.advanced_at,
  course.completed_at,
  course.created_at,
  course.description,
  course.id,
  course.name,
  course.number,
  course.status,
  course.study_id,
  course_topiced.topic_id,
  course_topiced.created_at topiced_at,
  course.updated_at,
  course.user_id
FROM course
JOIN course_topiced ON course_topiced.topicable_id = course.id;
CREATE VIEW
CREATE OR REPLACE VIEW topiced_study AS
SELECT
  study.advanced_at,
  study.created_at,
  study.description,
  study.id,
  study.name,
  study_topiced.topic_id,
  study_topiced.created_at topiced_at,
  study.updated_at,
  study.user_id,
  study.private
FROM study
JOIN study_topiced ON study_topiced.topicable_id = study.id;
CREATE VIEW
CREATE TABLE IF NOT EXISTS asset(
  created_at TIMESTAMPTZ  DEFAULT now(),
  id         BIGSERIAL    PRIMARY KEY,
  key        VARCHAR(40)  NOT NULL,
  name       TEXT         NOT NULL, 
  size       BIGINT       NOT NULL,
  subtype    TEXT         NOT NULL,
  type       TEXT         NOT NULL,
  user_id    VARCHAR(100) NOT NULL,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS asset_key_unique_idx
  ON asset (key);
CREATE INDEX
CREATE TABLE IF NOT EXISTS user_asset(
  asset_id     BIGINT       NOT NULL,
  id           VARCHAR(100) PRIMARY KEY,
  name         TEXT         NOT NULL CHECK(name ~ '[\w|-]+'),
  name_tokens  TEXT         NOT NULL,
  published_at TIMESTAMPTZ,
  study_id     VARCHAR(100) NOT NULL,
  updated_at   TIMESTAMPTZ  DEFAULT now(),
  user_id      VARCHAR(100) NOT NULL,
  FOREIGN KEY (asset_id)
    REFERENCES asset (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS user_asset_user_id_idx
  ON user_asset (user_id);
CREATE INDEX
CREATE UNIQUE INDEX IF NOT EXISTS user_asset_study_id_name_unique_idx
  ON user_asset (study_id, lower(name));
CREATE INDEX
CREATE OR REPLACE FUNCTION user_asset_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset'
    AND trigger_name = 'before_user_asset_update'
) THEN
  CREATE TRIGGER before_user_asset_update
    BEFORE UPDATE ON user_asset
    FOR EACH ROW EXECUTE PROCEDURE user_asset_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW user_asset_master AS
SELECT
  asset.id asset_id,
  asset.created_at,
  user_asset.id,
  asset.key,
  user_asset.name,
  user_asset.name_tokens,
  asset.name original_name,
  user_asset.published_at,
  asset.size,
  user_asset.study_id,
  asset.subtype,
  asset.type,
  user_asset.updated_at,
  user_asset.user_id
FROM user_asset
JOIN asset ON asset.id = user_asset.asset_id;
CREATE VIEW
CREATE TABLE IF NOT EXISTS user_asset_comment(
  body            TEXT,
  created_at      TIMESTAMPTZ  DEFAULT now(),
  id              VARCHAR(100) PRIMARY KEY,
  user_asset_id   VARCHAR(100) NOT NULL,
  published_at    TIMESTAMPTZ,
  study_id        VARCHAR(100) NOT NULL,
  user_id         VARCHAR(100) NOT NULL,
  updated_at      TIMESTAMPTZ  DEFAULT now(),
  FOREIGN KEY (user_asset_id)
    REFERENCES user_asset (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS user_asset_comment_user_id_idx
  ON user_asset_comment (user_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_asset_comment_study_id_idx
  ON user_asset_comment (study_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_asset_comment_user_asset_id_created_at_idx
  ON user_asset_comment (user_asset_id, created_at);
CREATE INDEX
CREATE OR REPLACE FUNCTION user_asset_comment_will_insert()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.study_id IS NULL THEN
    SELECT study.id
    INTO NEW.study_id
    FROM study
    JOIN user_asset ON user_asset.id = NEW.user_asset_id
    WHERE study.id = user_asset.study_id;
  END IF;
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_comment'
    AND trigger_name = 'before_user_asset_comment_insert'
) THEN
  CREATE TRIGGER before_user_asset_comment_insert
    BEFORE INSERT ON user_asset_comment
    FOR EACH ROW EXECUTE PROCEDURE user_asset_comment_will_insert();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION user_asset_comment_will_update()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_comment'
    AND trigger_name = 'before_user_asset_comment_update'
) THEN
  CREATE TRIGGER before_user_asset_comment_update
    BEFORE UPDATE ON user_asset_comment
    FOR EACH ROW EXECUTE PROCEDURE user_asset_comment_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS appled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  id            SERIAL       PRIMARY KEY,
  appleable_id  VARCHAR(100) NOT NULL,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS appled_unique_appleable_id_user_id_idx
  ON appled (appleable_id, user_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS appled_user_id_appleable_id_idx
  ON appled (user_id, appleable_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION insert_appled()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
DECLARE new_appled_id TEXT;
BEGIN
  INSERT INTO appled(user_id, appleable_id)
  VALUES (NEW.user_id, NEW.appleable_id)
  ON CONFLICT (appleable_id, user_id) DO NOTHING
  RETURNING id INTO new_appled_id;
  IF new_appled_id IS NULL THEN
    RETURN NULL;
  END IF;
  NEW.appled_id = new_appled_id;
  RETURN NEW;
END;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS course_appled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  appleable_id  VARCHAR(100) NOT NULL,
  appled_id     INT          PRIMARY KEY,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (appled_id)
    REFERENCES appled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (appleable_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS course_appled_user_id_appleable_id_idx
  ON course_appled (user_id, appleable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'course_appled'
    AND trigger_name = 'before_course_appled_insert'
) THEN
  CREATE TRIGGER before_course_appled_insert
    BEFORE INSERT ON course_appled
    FOR EACH ROW EXECUTE PROCEDURE insert_appled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS study_appled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  appleable_id  VARCHAR(100) NOT NULL,
  appled_id     INT          PRIMARY KEY,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (appled_id)
    REFERENCES appled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (appleable_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS study_appled_user_id_appleable_id_idx
  ON study_appled (user_id, appleable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'study_appled'
    AND trigger_name = 'before_study_appled_insert'
) THEN
  CREATE TRIGGER before_study_appled_insert
    BEFORE INSERT ON study_appled
    FOR EACH ROW EXECUTE PROCEDURE insert_appled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW apple_giver AS
SELECT
  user_master.*,
  appled.appleable_id,
  appled.created_at appled_at
FROM user_master
JOIN appled ON appled.user_id = user_master.id;
CREATE VIEW
CREATE OR REPLACE VIEW appled_course AS
SELECT
  course_appled.user_id applee_id,
  course.advanced_at,
  course_appled.created_at appled_at,
  course.completed_at,
  course.created_at,
  course.description,
  course.id,
  course.name,
  course.number,
  course.status,
  course.study_id,
  course.updated_at,
  course.user_id
FROM course
JOIN course_appled ON course_appled.appleable_id = course.id;
CREATE VIEW
CREATE OR REPLACE VIEW appled_study AS
SELECT
  study_appled.user_id applee_id,
  study.advanced_at,
  study_appled.created_at appled_at,
  study.created_at,
  study.description,
  study.id,
  study.name,
  study.private,
  study.updated_at,
  study.user_id
FROM study
JOIN study_appled ON study_appled.appleable_id = study.id;
CREATE VIEW
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'enrollment_status') THEN
    CREATE TYPE enrollment_status AS ENUM('ENROLLED', 'IGNORED', 'UNENROLLED');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS enrolled(
  created_at    TIMESTAMPTZ       DEFAULT now(),
  id            SERIAL            PRIMARY KEY,
  enrollable_id VARCHAR(100)      NOT NULL,
  user_id       VARCHAR(100)      NOT NULL,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS enrolled_unique_enrollable_id_user_id_idx
  ON enrolled (enrollable_id, user_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS enrolled_user_id_enrollable_id_idx
  ON enrolled (user_id, enrollable_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION insert_enrolled()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO enrolled(enrollabled_id, user_id)
  VALUES (NEW.enrollable_id, NEW.user_id)
  ON CONFLICT (enrollable_id, user_id) DO NOTHING
  RETURNING id INTO NEW.enrolled_id;

  RETURN NEW;
END;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS reason (
  created_at  TIMESTAMPTZ DEFAULT now(),
  description TEXT        NOT NULL,
  name        VARCHAR(40) PRIMARY KEY
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS reason_unique_lower_name_idx
  ON reason (lower(name));
CREATE INDEX
INSERT INTO reason (name, description)
VALUES
  ('author', 'You created the thread.'),
  ('comment', 'You commented on the thread.'),
  ('enrolled', E'You\'re enrolled in the study.'),
  ('manual', 'You enrolled in the thread.'),
  ('mention', 'You were @mentioned in the thread.')
ON CONFLICT (name) DO NOTHING;
INSERT 0 5
CREATE TABLE IF NOT EXISTS lesson_enrolled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  enrollable_id VARCHAR(100) NOT NULL,
  enrolled_id   INT          PRIMARY KEY,
  reason_name   VARCHAR(40)  NOT NULL,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (enrolled_id)
    REFERENCES enrolled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (enrollable_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (reason_name)
    REFERENCES reason (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS lesson_enrolled_user_id_enrollable_id_idx
  ON lesson_enrolled (user_id, enrollable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'lesson_enrolled'
    AND trigger_name = 'before_lesson_enrolled_insert'
) THEN
  CREATE TRIGGER before_lesson_enrolled_insert
    BEFORE INSERT ON lesson_enrolled
    FOR EACH ROW EXECUTE PROCEDURE insert_enrolled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS course_enrolled(
  created_at    TIMESTAMPTZ  DEFAULT now(),
  enrollable_id VARCHAR(100) NOT NULL,
  enrolled_id   INT          PRIMARY KEY,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (enrolled_id)
    REFERENCES enrolled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (enrollable_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS course_enrolled_user_id_enrollable_id_idx
  ON course_enrolled (user_id, enrollable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'course_enrolled'
    AND trigger_name = 'before_course_enrolled_insert'
) THEN
  CREATE TRIGGER before_course_enrolled_insert
    BEFORE INSERT ON course_enrolled
    FOR EACH ROW EXECUTE PROCEDURE insert_enrolled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS study_enrolled(
  created_at    TIMESTAMPTZ       DEFAULT now(),
  enrollable_id VARCHAR(100)      NOT NULL,
  enrolled_id   INT               PRIMARY KEY,
  status        enrollment_status DEFAULT 'ENROLLED',
  user_id       VARCHAR(100)      NOT NULL,
  FOREIGN KEY (enrolled_id)
    REFERENCES enrolled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (enrollable_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS study_enrolled_user_id_enrollable_id_idx
  ON study_enrolled (user_id, enrollable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'study_enrolled'
    AND trigger_name = 'before_study_enrolled_insert'
) THEN
  CREATE TRIGGER before_study_enrolled_insert
    BEFORE INSERT ON study_enrolled
    FOR EACH ROW EXECUTE PROCEDURE insert_enrolled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_enrolled(
  created_at    TIMESTAMPTZ       DEFAULT now(),
  enrollable_id VARCHAR(100)      NOT NULL,
  enrolled_id   INT               PRIMARY KEY,
  status        enrollment_status DEFAULT 'ENROLLED',
  user_id       VARCHAR(100)      NOT NULL,
  FOREIGN KEY (enrolled_id)
    REFERENCES enrolled (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (enrollable_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS user_enrolled_user_id_enrollable_id_idx
  ON user_enrolled (user_id, enrollable_id);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE  event_object_table = 'user_enrolled'
    AND trigger_name = 'before_user_enrolled_insert'
) THEN
  CREATE TRIGGER before_user_enrolled_insert
    BEFORE INSERT ON user_enrolled
    FOR EACH ROW EXECUTE PROCEDURE insert_enrolled();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW enrollee AS
SELECT
  user_master.*,
  enrolled.enrollable_id,
  enrolled.created_at enrolled_at
FROM user_master
JOIN enrolled ON enrolled.user_id = user_master.id;
CREATE VIEW
CREATE OR REPLACE VIEW enrolled_lesson AS
SELECT
  lesson_master.*,
  lesson_enrolled.created_at enrolled_at,
  lesson_enrolled.user_id enrollee_id
FROM lesson_master
JOIN lesson_enrolled ON lesson_enrolled.enrollable_id = lesson_master.id; 
CREATE VIEW
CREATE OR REPLACE VIEW enrolled_course AS
SELECT
  course.advanced_at,
  course.completed_at,
  course.created_at,
  course.description,
  course_enrolled.created_at enrolled_at,
  course_enrolled.user_id enrollee_id,
  course.id,
  course.name,
  course.number,
  course.status,
  course.study_id,
  course.updated_at,
  course.user_id
FROM course
JOIN course_enrolled ON course_enrolled.enrollable_id = course.id; 
CREATE VIEW
CREATE OR REPLACE VIEW enrolled_study AS
SELECT
  study.advanced_at,
  study.created_at,
  study.description,
  study_enrolled.created_at enrolled_at,
  study_enrolled.user_id enrollee_id,
  study.id,
  study.name,
  study.updated_at,
  study.user_id,
  study.private
FROM study
JOIN study_enrolled ON study_enrolled.enrollable_id = study.id; 
CREATE VIEW
CREATE OR REPLACE VIEW enrolled_user AS
SELECT
  user_master.*,
  user_enrolled.created_at enrolled_at,
  user_enrolled.user_id enrollee_id
FROM user_master
JOIN user_enrolled ON user_enrolled.enrollable_id = user_master.id;
CREATE VIEW
CREATE TABLE IF NOT EXISTS event_type (
  created_at  TIMESTAMPTZ DEFAULT now(),
  description TEXT        NOT NULL,
  name        VARCHAR(40) PRIMARY KEY
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS action_unique_lower_name_idx
  ON event_type (lower(name));
CREATE INDEX
INSERT INTO event_type (name, description)
VALUES
  ('CourseEvent', 'Triggered when a course is created, appled, or unappled.'),
  ('LessonCommentEvent', 'Triggered when a lesson comment is created. 
    Also triggered when a user is mentioned in the comment body.'),
  ('LessonEvent', 'Triggered when a lesson is created, added to a course, 
    removed from a course, commented, labeled, unlabeled, referenced, or renamed. 
    Also triggered when a user is mentioned in the lesson body.'),
  ('PublicEvent', 'Triggered when a study is made public.'),
  ('UserAssetCommentEvent', 'Triggered when a user asset comment is created. 
    Also triggered when a user is mentioned in the comment body.'),
  ('UserAssetEvent', 'Triggered when a user asset is created.'),
  ('StudyEvent', 'Triggered when a study is created, appled, or unappled.')
ON CONFLICT (name) DO NOTHING;
INSERT 0 7
CREATE TABLE IF NOT EXISTS event (
  created_at  TIMESTAMPTZ  DEFAULT now(),
  id          VARCHAR(100) PRIMARY KEY,
  payload     JSONB,
  public      BOOLEAN      DEFAULT false,
  study_id    VARCHAR(100) NOT NULL,
  type        VARCHAR(40)  NOT NULL,
  user_id     VARCHAR(100) NOT NULL,
  FOREIGN KEY (type)
    REFERENCES event_type (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS event_study_id_type_created_at_idx
  ON event (study_id, type, created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS event_user_id_type_created_at_idx
  ON event (user_id, type, created_at);
CREATE INDEX
CREATE OR REPLACE FUNCTION event_inserted()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.type = 'CourseEvent' THEN
    INSERT INTO course_event (action, course_id, event_id)
    VALUES (
      (NEW.payload->>'action')::course_event_action,
      NEW.payload->>'course_id',
      NEW.id
    );

    INSERT INTO course_enrolled(enrollable_id, user_id)
    VALUES (NEW.payload->>'course_id', NEW.user_id);

    INSERT INTO course_enrolled(enrollable_id, user_id)
    SELECT 
      NEW.payload->>'course_id',
      user_id
    FROM study_enrolled
    WHERE study_id = NEW.study_id;
  ELSIF NEW.type = 'LessonCommentEvent' THEN
    INSERT INTO lesson_comment_event (action, comment_id, event_id, lesson_id)
    VALUES (
      (NEW.payload->>'action')::lesson_comment_event_action,
      NEW.payload->>'comment_id',
      NEW.id,
      NEW.payload->>'lesson_id'
    );

    INSERT INTO lesson_enrolled(enrollable_id, reason_name, user_id)
    VALUES (NEW.lesson_id, 'comment', NEW.user_id)
    ON CONFLICT (enrollable_id, user_id) DO UPDATE
      SET reason_name = 'comment';
  ELSIF NEW.type = 'LessonEvent' THEN
    INSERT INTO lesson_event (action, created_at, event_id, lesson_id, payload)
    VALUES (
      NEW.payload->>'action',
      NEW.created_at,
      NEW.id,
      NEW.payload->>'lesson_id',
      NEW.payload
    );

    IF NEW.payload->>'action' = 'created' THEN
      INSERT INTO lesson_enrolled(enrollable_id, reason_name, user_id)
      VALUES (NEW.payload->>'lesson_id', 'author', NEW.user_id);

      INSERT INTO lesson_enrolled(enrollable_id, reason_name, user_id)
      SELECT 
        NEW.payload->>'lesson_id',
        'enrolled',
        user_id
      FROM study_enrolled
      WHERE study_id = NEW.study_id;
    END IF;
  ELSIF NEW.type = 'StudyEvent' THEN
    INSERT INTO study_event (action, event_id)
    VALUES (
      (NEW.payload->>'action')::study_event_action,
      NEW.id
    );
    INSERT INTO study_enrolled(enrollable_id, user_id)
    VALUES (NEW.study_id, NEW.user_id);
  ELSIF NEW.type = 'UserAssetCommentEvent' THEN
    INSERT INTO user_asset_comment_event (action, asset_id, comment_id, event_id)
    VALUES (
      (NEW.payload->>'action')::user_asset_comment_event_action,
      NEW.payload->>'asset_id',
      NEW.payload->>'comment_id',
      NEW.id
    );
  ELSIF NEW.type = 'UserAssetEvent' THEN
    INSERT INTO user_asset_event (action, asset_id, created_at, event_id, payload)
    VALUES (
      NEW.payload->>'action',
      NEW.payload->>'asset_id',
      NEW.created_at,
      NEW.id,
      NEW.payload
    );
  END IF;

  NEW.payload = NULL;

  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'event'
    AND trigger_name = 'after_event_insert'
) THEN
  CREATE TRIGGER after_event_insert
    AFTER INSERT ON event
    FOR EACH ROW EXECUTE PROCEDURE event_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS received_event (
  event_id      VARCHAR(100) NOT NULL,
  user_id       VARCHAR(100) NOT NULL,
  PRIMARY KEY (user_id, event_id),
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE OR REPLACE VIEW received_event_master AS
SELECT
  event_master.*,
  received_event.user_id AS received_user_id
FROM received_event
JOIN event_master ON event_master.id = received_event.event_id;
psql:data/init_database.sql:1833: ERROR:  relation "event_master" does not exist
LINE 6: JOIN event_master ON event_master.id = received_event.event_...
             ^
CREATE OR REPLACE FUNCTION delete_event()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM event
  WHERE id = OLD.event_id;
  RETURN OLD;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'course_event_action') THEN
    CREATE TYPE course_event_action AS ENUM('created', 'appled', 'unappled');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS course_event (
  action     course_event_action NOT NULL,
  course_id  VARCHAR(100)        NOT NULL,
  event_id   VARCHAR(100)        PRIMARY KEY,
  FOREIGN KEY (course_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course_event'
    AND trigger_name = 'after_course_event_delete'
) THEN
  CREATE TRIGGER after_course_event_delete
    AFTER DELETE ON course_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'lesson_comment_event_action') THEN
    CREATE TYPE lesson_comment_event_action AS ENUM('created', 'mentioned');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_comment_event (
  action     lesson_comment_event_action NOT NULL,
  comment_id VARCHAR(100)                NOT NULL,
  event_id   VARCHAR(100)                PRIMARY KEY,
  lesson_id  VARCHAR(100)                NOT NULL,
  FOREIGN KEY (comment_id)
    REFERENCES lesson_comment (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (lesson_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_comment_event'
    AND trigger_name = 'after_lesson_comment_event_delete'
) THEN
  CREATE TRIGGER after_lesson_comment_event_delete
    AFTER DELETE ON lesson_comment_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_event_action (
  created_at  TIMESTAMPTZ DEFAULT now(),
  description TEXT        NOT NULL,
  name        VARCHAR(40) PRIMARY KEY
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS lesson_event_action_unique_lower_name_idx
  ON lesson_event_action (lower(name));
CREATE INDEX
INSERT INTO lesson_event_action (name, description)
VALUES
  ('added_to_course', 'The lesson was added to a course.'),
  ('created', 'The lesson was created.'),
  ('commented', 'A comment was added to the lesson.'),
  ('labeled', 'A label was added to the lesson.'),
  ('mentioned', 'The user was @mentioned in the lesson body.'),
  ('referenced', 'The lesson was referenced from another lesson.'),
  ('removed_from_course', 'The lesson was removed from a course'),
  ('renamed', 'The lesson title was changed.'),
  ('unlabeled', 'A label was removed from the lesson.')
ON CONFLICT (name) DO NOTHING;
INSERT 0 9
CREATE TABLE IF NOT EXISTS lesson_event (
  action     VARCHAR(40)  NOT NULL,
  created_at TIMESTAMPTZ  DEFAULT now(),
  event_id   VARCHAR(100) PRIMARY KEY,
  lesson_id  VARCHAR(100) NOT NULL,
  payload    JSONB        NOT NULL,
  FOREIGN KEY (action)
    REFERENCES lesson_event_action (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (lesson_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS lesson_event_lesson_id_action_created_at
  ON lesson_event (lesson_id, action, created_at);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_event'
    AND trigger_name = 'after_lesson_event_delete'
) THEN
  CREATE TRIGGER after_lesson_event_delete
    AFTER DELETE ON lesson_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION lesson_event_inserted()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.action = 'added_to_course' THEN
    INSERT INTO lesson_added_to_course_event (course_id, event_id)
    VALUES (
      NEW.payload->>'course_id',
      NEW.event_id
    );
  ELSIF NEW.action = 'commented' THEN
    INSERT INTO lesson_commented_event (comment_id, event_id)
    VALUES (
      NEW.payload->>'comment_id',
      NEW.event_id
    );
  ELSIF NEW.action = 'labeled' THEN
    INSERT INTO lesson_labeled_event (event_id, label_id)
    VALUES (
      NEW.event_id,
      NEW.payload->>'label_id'
    );
  ELSIF NEW.action = 'referenced' THEN
    INSERT INTO lesson_referenced_event (event_id, source_id)
    VALUES (
      NEW.event_id,
      NEW.payload->>'source_id'
    );
  ELSIF NEW.action = 'removed_from_course' THEN
    INSERT INTO lesson_removed_from_course_event (course_id, event_id)
    VALUES (
      NEW.payload->>'course_id',
      NEW.event_id
    );
  ELSIF NEW.action = 'renamed' THEN
    INSERT INTO lesson_renamed_event (event_id, renamed_from, renamed_to)
    VALUES (
      NEW.event_id,
      NEW.payload->'rename'->>'from',
      NEW.payload->'rename'->>'to'
    );
  ELSIF NEW.action = 'unlabeled' THEN
    INSERT INTO lesson_unlabeled_event (event_id, label_id)
    VALUES (
      NEW.event_id,
      NEW.payload->>'label_id'
    );
  END IF;

  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_event'
    AND trigger_name = 'after_lesson_event_insert'
) THEN
  CREATE TRIGGER after_lesson_event_insert
    AFTER INSERT ON lesson_event
    FOR EACH ROW EXECUTE PROCEDURE lesson_event_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_added_to_course_event (
  course_id       VARCHAR(100) NOT NULL,
  event_id        VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (course_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_added_to_course_event'
    AND trigger_name = 'after_lesson_added_to_course_event_delete'
) THEN
  CREATE TRIGGER after_lesson_added_to_course_event_delete
    AFTER DELETE ON lesson_added_to_course_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_commented_event (
  comment_id      VARCHAR(100) NOT NULL,
  event_id        VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (comment_id)
    REFERENCES lesson_comment (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_commented_event'
    AND trigger_name = 'after_lesson_commented_event_delete'
) THEN
  CREATE TRIGGER after_lesson_commented_event_delete
    AFTER DELETE ON lesson_commented_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_labeled_event (
  event_id        VARCHAR(100) PRIMARY KEY,
  label_id        VARCHAR(100) NOT NULL,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (label_id)
    REFERENCES label (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_labeled_event'
    AND trigger_name = 'after_lesson_labeled_event_delete'
) THEN
  CREATE TRIGGER after_lesson_labeled_event_delete
    AFTER DELETE ON lesson_labeled_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_referenced_event (
  event_id        VARCHAR(100) PRIMARY KEY,
  source_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (source_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_referenced_event'
    AND trigger_name = 'after_lesson_referenced_event_delete'
) THEN
  CREATE TRIGGER after_lesson_referenced_event_delete
    AFTER DELETE ON lesson_referenced_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_removed_from_course_event (
  course_id       VARCHAR(100) NOT NULL,
  event_id        VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (course_id)
    REFERENCES course (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_removed_from_course_event'
    AND trigger_name = 'after_lesson_removed_from_course_event_delete'
) THEN
  CREATE TRIGGER after_lesson_removed_from_course_event_delete
    AFTER DELETE ON lesson_removed_from_course_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_renamed_event (
  event_id        VARCHAR(100) PRIMARY KEY,
  renamed_from    TEXT         NOT NULL,
  renamed_to      TEXT         NOT NULL,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE TABLE IF NOT EXISTS lesson_unlabeled_event (
  event_id        VARCHAR(100) PRIMARY KEY,
  label_id        VARCHAR(100) NOT NULL,
  FOREIGN KEY (event_id)
    REFERENCES lesson_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (label_id)
    REFERENCES label (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_unlabeled_event'
    AND trigger_name = 'after_lesson_unlabeled_event_delete'
) THEN
  CREATE TRIGGER after_lesson_unlabeled_event_delete
    AFTER DELETE ON lesson_unlabeled_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW lesson_event_master AS
SELECT
  lesson_event.action,
  event.created_at,
  event.id,
  lesson_event.lesson_id,
  lesson_event.payload,
  event.public,
  event.study_id,
  event.type,
  event.user_id
FROM lesson_event
JOIN event ON event.id = lesson_event.event_id;
CREATE VIEW
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'study_event_action') THEN
    CREATE TYPE study_event_action AS ENUM('created', 'appled', 'unappled');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS study_event (
  action   study_event_action NOT NULL,
  event_id VARCHAR(100)       PRIMARY KEY,
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_asset_comment_event_action') THEN
    CREATE TYPE user_asset_comment_event_action AS ENUM('created', 'mentioned');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_comment_event (
  action     user_asset_comment_event_action NOT NULL,
  asset_id   VARCHAR(100)                    NOT NULL,
  comment_id VARCHAR(100)                    NOT NULL,
  event_id   VARCHAR(100)                    PRIMARY KEY,
  FOREIGN KEY (asset_id)
    REFERENCES user_asset (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (comment_id)
    REFERENCES user_asset_comment (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_comment_event'
    AND trigger_name = 'after_user_asset_comment_event_delete'
) THEN
  CREATE TRIGGER after_user_asset_comment_event_delete
    AFTER DELETE ON user_asset_comment_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_event_action (
  created_at  TIMESTAMPTZ DEFAULT now(),
  description TEXT        NOT NULL,
  name        VARCHAR(40) PRIMARY KEY
);
CREATE TABLE
CREATE UNIQUE INDEX IF NOT EXISTS user_asset_event_action_unique_lower_name_idx
  ON user_asset_event_action (lower(name));
CREATE INDEX
INSERT INTO user_asset_event_action (name, description)
VALUES
  ('created', 'The user asset was created.'),
  ('commented', 'A comment was added to the user asset.'),
  ('referenced', 'The user asset was referenced from a lesson.'),
  ('renamed', 'The user asset name was changed.')
ON CONFLICT (name) DO NOTHING;
INSERT 0 4
CREATE TABLE IF NOT EXISTS user_asset_event (
  action     VARCHAR(40)  NOT NULL,
  asset_id   VARCHAR(100) NOT NULL,
  created_at TIMESTAMPTZ  DEFAULT now(),
  event_id   VARCHAR(100) PRIMARY KEY,
  payload    JSONB        NOT NULL,
  FOREIGN KEY (action)
    REFERENCES user_asset_event_action (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES event (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (asset_id)
    REFERENCES user_asset (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS user_asset_event_asset_id_action_created_at
  ON user_asset_event (asset_id, action, created_at);
CREATE INDEX
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_event'
    AND trigger_name = 'after_user_asset_event_delete'
) THEN
  CREATE TRIGGER after_user_asset_event_delete
    AFTER DELETE ON user_asset_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION user_asset_event_inserted()
  RETURNS TRIGGER
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.action = 'commented' THEN
    INSERT INTO user_asset_commented_event (comment_id, event_id)
    VALUES (
      NEW.payload->>'comment_id',
      NEW.event_id
    );
  ELSIF NEW.action = 'referenced' THEN
    INSERT INTO user_asset_referenced_event (event_id, source_id)
    VALUES (
      NEW.event_id,
      NEW.payload->>'source_id'
    );
  ELSIF NEW.action = 'renamed' THEN
    INSERT INTO user_asset_renamed_event (event_id, renamed_from, renamed_to)
    VALUES (
      NEW.event_id,
      NEW.payload->'rename'->>'from',
      NEW.payload->'rename'->>'to'
    );
  END IF;

  RETURN NEW;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_event'
    AND trigger_name = 'after_user_asset_event_insert'
) THEN
  CREATE TRIGGER after_user_asset_event_insert
    AFTER INSERT ON user_asset_event
    FOR EACH ROW EXECUTE PROCEDURE user_asset_event_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_commented_event (
  comment_id VARCHAR(100) NOT NULL,
  event_id   VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (comment_id)
    REFERENCES user_asset_comment (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (event_id)
    REFERENCES user_asset_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_commented_event'
    AND trigger_name = 'after_user_asset_commented_event_delete'
) THEN
  CREATE TRIGGER after_user_asset_commented_event_delete
    AFTER DELETE ON user_asset_commented_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_referenced_event (
  event_id  VARCHAR(100) PRIMARY KEY,
  source_id VARCHAR(100) NOT NULL,
  FOREIGN KEY (event_id)
    REFERENCES user_asset_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (source_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_referenced_event'
    AND trigger_name = 'after_user_asset_referenced_event_delete'
) THEN
  CREATE TRIGGER after_user_asset_referenced_event_delete
    AFTER DELETE ON user_asset_referenced_event
    FOR EACH ROW EXECUTE PROCEDURE delete_event();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_renamed_event (
  event_id     VARCHAR(100) PRIMARY KEY,
  renamed_from TEXT         NOT NULL,
  renamed_to   TEXT         NOT NULL,
  FOREIGN KEY (event_id)
    REFERENCES user_asset_event (event_id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE OR REPLACE VIEW user_asset_event_master AS
SELECT
  user_asset_event.action,
  user_asset_event.asset_id,
  event.created_at,
  event.id,
  user_asset_event.payload,
  event.public,
  event.study_id,
  event.type,
  event.user_id
FROM user_asset_event
JOIN event ON event.id = user_asset_event.event_id;
CREATE VIEW
CREATE OR REPLACE VIEW event_master AS
SELECT
  event.created_at,
  event.id,
  event.public,
  event.study_id,
  event.type,
  event.user_id,
  CASE 
    WHEN course_event IS NOT NULL THEN
      jsonb_build_object(
        'action', course_event.action,
        'course_id', course_event.course_id
      )
    WHEN lesson_comment_event IS NOT NULL THEN
      jsonb_build_object(
        'action', lesson_comment_event.action,
        'comment_id', lesson_comment_event.comment_id,
        'lesson_id', lesson_comment_event.lesson_id
      )
    WHEN lesson_event_master IS NOT NULL THEN
      lesson_event_master.payload
    WHEN study_event IS NOT NULL THEN
      jsonb_build_object(
        'action', study_event.action,
        'study_id', event.study_id
      )
    WHEN user_asset_comment_event IS NOT NULL THEN
      jsonb_build_object(
        'action', user_asset_comment_event.action,
        'asset_id', user_asset_comment_event.asset_id,
        'comment_id', user_asset_comment_event.comment_id
      )
    WHEN user_asset_event_master IS NOT NULL THEN
      user_asset_event_master.payload
    ELSE NULL
  END AS payload
FROM event
LEFT JOIN course_event ON event.type = 'CourseEvent' AND course_event.event_id = event.id
LEFT JOIN lesson_comment_event ON event.type = 'LessonCommentEvent' AND lesson_comment_event.event_id = event.id
LEFT JOIN lesson_event_master ON event.type = 'LessonEvent' AND lesson_event_master.id = event.id
LEFT JOIN user_asset_comment_event ON event.type = 'UserAssetCommentEvent' AND user_asset_comment_event.event_id = event.id
LEFT JOIN user_asset_event_master ON event.type = 'UserAssetEvent' AND user_asset_event_master.id = event.id
LEFT JOIN study_event ON event.type = 'StudyEvent' AND study_event.event_id = event.id;
CREATE VIEW
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_subject_type') THEN
    CREATE TYPE notification_subject_type AS ENUM('Lesson', 'UserAsset');
  END IF;
END
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS notification (
  created_at    TIMESTAMPTZ               DEFAULT now(),
  id            VARCHAR(100)              PRIMARY KEY,
  last_read_at  TIMESTAMPTZ,
  reason_name   VARCHAR(40)               NOT NULL,
  subject       notification_subject_type NOT NULL,
  subject_id    VARCHAR(100)              NOT NULL,
  study_id      VARCHAR(100)              NOT NULL,
  unread        BOOLEAN                   DEFAULT true,
  updated_at    TIMESTAMPTZ               DEFAULT now(),
  user_id       VARCHAR(100)              NOT NULL,
  FOREIGN KEY (reason_name)
    REFERENCES reason (name)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS notification_user_id_study_id_created_at_idx
  ON notification (user_id, study_id, created_at ASC);
CREATE INDEX
CREATE OR REPLACE FUNCTION notification_will_insert()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.subject = 'Lesson' THEN
    INSERT INTO lesson_notification(id, lesson_id)
    VALUES (NEW.notification_id, NEW.subject_id);
  ELSIF NEW.subject = 'UserAsset' THEN
    INSERT INTO user_asset_notification(id, asset_id)
    VALUES (NEW.notification_id, NEW.subject_id);
  END IF;
END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'notification'
    AND trigger_name = 'before_notification_insert'
) THEN
  CREATE TRIGGER before_notification_insert
    BEFORE INSERT ON notification
    FOR EACH ROW EXECUTE PROCEDURE notification_will_insert();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION notification_will_update()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    NEW.updated_at = now();
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'notification'
    AND trigger_name = 'before_notification_update'
) THEN
  CREATE TRIGGER before_notification_update
    BEFORE INSERT ON notification
    FOR EACH ROW EXECUTE PROCEDURE notification_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION delete_notification()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM notification
  WHERE id = OLD.notification_id;
  RETURN OLD;
END;
$$;
CREATE FUNCTION
CREATE TABLE IF NOT EXISTS lesson_notification (
  lesson_id       VARCHAR(100) NOT NULL,
  notification_id VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (lesson_id)
    REFERENCES lesson (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (notification_id)
    REFERENCES notification (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_notification'
    AND trigger_name = 'after_lesson_notification_delete'
) THEN
  CREATE TRIGGER after_lesson_notification_delete
    AFTER DELETE ON lesson_notification
    FOR EACH ROW EXECUTE PROCEDURE delete_notification();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_notification (
  asset_id       VARCHAR(100) NOT NULL,
  notification_id VARCHAR(100) PRIMARY KEY,
  FOREIGN KEY (asset_id)
    REFERENCES user_asset (id)
    ON UPDATE NO ACTION ON DELETE CASCADE,
  FOREIGN KEY (notification_id)
    REFERENCES notification (id)
    ON UPDATE NO ACTION ON DELETE CASCADE
);
CREATE TABLE
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset_notification'
    AND trigger_name = 'after_user_asset_notification_delete'
) THEN
  CREATE TRIGGER after_user_asset_notification_delete
    AFTER DELETE ON user_asset_notification
    FOR EACH ROW EXECUTE PROCEDURE delete_notification();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE VIEW notification_master AS
SELECT
  notification.*,
  reason.description AS reason
FROM notification
JOIN reason ON reason.name = notification.reason_name;
CREATE VIEW
CREATE TABLE IF NOT EXISTS user_search_index (
  account_updated_at  TIMESTAMPTZ  NOT NULL,
  bio                 TEXT,
  created_at          TIMESTAMPTZ  NOT NULL,
  document            TSVECTOR     NOT NULL,
  enrollee_count      BIGINT       NOT NULL DEFAULT 0,
  id                  VARCHAR(100) PRIMARY KEY,
  login               VARCHAR(40)  NOT NULL,
  name                TEXT         CHECK(name ~ '^[\w|-][\w|-|\s]+[\w|-]$'),
  profile_email_id    VARCHAR(100),
  profile_updated_at  TIMESTAMPTZ  NOT NULL,
  roles               TEXT [],
  study_count         BIGINT       NOT NULL DEFAULT 0,
  FOREIGN KEY (id)
    REFERENCES account (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (profile_email_id)
    REFERENCES email (id)
    ON UPDATE NO ACTION ON DELETE NO ACTION
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS user_search_index_fts_idx
  ON user_search_index USING gin(document);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_search_index_created_at_idx
  ON user_search_index (created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_search_index_enrollee_count_idx
  ON user_search_index (enrollee_count);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_search_index_study_count_idx
  ON user_search_index (study_count);
CREATE INDEX
CREATE OR REPLACE FUNCTION account_will_insert()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    profile_updated_at TIMESTAMPTZ;
  BEGIN
    INSERT INTO user_profile(user_id)
    VALUES (NEW.id)
    RETURNING updated_at INTO profile_updated_at;
    INSERT INTO user_search_index(
      account_updated_at,
      created_at,
      document,
      id,
      login,
      profile_updated_at
    ) VALUES (
      NEW.updated_at,
      NEW.created_at,
      setweight(to_tsvector('simple', NEW.login), 'A'),
      NEW.id,
      NEW.login,
      profile_updated_at
    );
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'account'
    AND trigger_name = 'after_account_insert'
) THEN
  CREATE TRIGGER after_account_insert
    AFTER INSERT ON account
    FOR EACH ROW EXECUTE PROCEDURE account_will_insert();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION account_will_update()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    NEW.updated_at = now();
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'account'
    AND trigger_name = 'before_account_update'
) THEN
  CREATE TRIGGER before_account_update
    BEFORE INSERT ON account
    FOR EACH ROW EXECUTE PROCEDURE account_will_update();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION account_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.login != OLD.login THEN
      doc = (
        SELECT 
          setweight(to_tsvector('simple', NEW.login), 'A') ||
          setweight(to_tsvector('simple', coalesce(user_profile.name, '')), 'A') ||
          setweight(to_tsvector('simple', coalesce(user_profile.bio, '')), 'B') ||
          setweight(to_tsvector('simple', coalesce(email.value, '')), 'B')
        FROM user_profile
        LEFT JOIN email ON email.id = user_profile.email_id
        WHERE user_profile.user_id = NEW.id
      );
    ELSE
      doc = (SELECT document FROM user_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE user_search_index
    SET 
      account_updated_at = NEW.updated_at,
      document = doc,
      login = NEW.login
    WHERE id = NEW.id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'account'
    AND trigger_name = 'after_account_update'
) THEN
  CREATE TRIGGER after_account_update
    AFTER UPDATE ON account
    FOR EACH ROW EXECUTE PROCEDURE account_updated();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION user_profile_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.name != OLD.name OR NEW.bio != OLD.bio OR NEW.email_id != OLD.email_id THEN
      doc = (
        SELECT 
          setweight(to_tsvector('simple', account.login), 'A') ||
          setweight(to_tsvector('simple', coalesce(NEW.name, '')), 'A') ||
          setweight(to_tsvector('simple', coalesce(NEW.bio, '')), 'B') ||
          setweight(to_tsvector('simple', coalesce(email.value, '')), 'B')
        FROM account
        LEFT JOIN email ON email.id = NEW.email_id
        WHERE account.id = NEW.user_id
      );
    ELSE
      doc = (SELECT document FROM user_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE user_search_index
    SET 
      bio = NEW.bio,
      document = doc,
      name = NEW.name,
      profile_email_id = NEW.email_id,
      profile_updated_at = NEW.updated_at
    WHERE id = NEW.user_id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_profile'
    AND trigger_name = 'after_user_profile_update'
) THEN
  CREATE TRIGGER after_user_profile_update
    AFTER UPDATE ON user_profile
    FOR EACH ROW EXECUTE PROCEDURE user_profile_updated();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_user_search_index_roles(_user_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE user_search_index
  SET roles = ARRAY(
    SELECT role.name
    FROM role
    LEFT JOIN user_role ON user_role.user_id = _user_id
    WHERE role.name = user_role.role
  )
  WHERE id = _user_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION user_role_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_user_search_index_roles(NEW.user_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_role'
    AND trigger_name = 'after_user_role_insert'
) THEN
  CREATE TRIGGER after_user_role_insert
    AFTER INSERT ON user_role
    FOR EACH ROW EXECUTE PROCEDURE user_role_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION user_role_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_user_search_index_roles(OLD.user_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_role'
    AND trigger_name = 'after_user_role_delete'
) THEN
  CREATE TRIGGER after_user_role_delete
    AFTER DELETE ON user_role
    FOR EACH ROW EXECUTE PROCEDURE user_role_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_user_search_index_study_count(_user_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE user_search_index
  SET study_count = (
    SELECT count(study) study_count 
    FROM study
    WHERE study.user_id = _user_id
  )
  WHERE id = _user_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION study_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_user_search_index_study_count(OLD.user_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'study'
    AND trigger_name = 'after_study_delete'
) THEN
  CREATE TRIGGER after_study_delete
    AFTER DELETE ON study
    FOR EACH ROW EXECUTE PROCEDURE study_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_user_search_index_enrollee_count(_user_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE user_search_index
  SET enrollee_count = (
    SELECT count(enrolled) enrollee_count 
    FROM enrolled
    WHERE enrolled.enrollable_id = _user_id
  )
  WHERE id = _user_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION enrolled_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_user_search_index_enrollee_count(NEW.user_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'enrolled'
    AND trigger_name = 'after_enrolled_insert'
) THEN
  CREATE TRIGGER after_enrolled_insert
    AFTER INSERT ON enrolled
    FOR EACH ROW EXECUTE PROCEDURE enrolled_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION enrolled_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_user_search_index_enrollee_count(OLD.user_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'enrolled'
    AND trigger_name = 'after_enrolled_delete'
) THEN
  CREATE TRIGGER after_enrolled_delete
    AFTER DELETE ON enrolled
    FOR EACH ROW EXECUTE PROCEDURE enrolled_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS course_search_index (
  advanced_at   TIMESTAMPTZ,
  apple_count   BIGINT       NOT NULL DEFAULT 0,
  completed_at  TIMESTAMPTZ,
  created_at    TIMESTAMPTZ  NOT NULL,
  description   TEXT,
  document      TSVECTOR     NOT NULL,
  id            VARCHAR(100) PRIMARY KEY,
  lesson_count  BIGINT       NOT NULL DEFAULT 0,
  name          TEXT         NOT NULL CHECK (name ~ '[\w|-]+'),
  name_tokens   TEXT         NOT NULL,
  number        INT          NOT NULL CHECK(number > 0),
  status        course_status NOT NULL,
  study_id      VARCHAR(100) NOT NULL,
  topics        TSVECTOR     NOT NULL,   
  updated_at    TIMESTAMPTZ  NOT NULL,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (id)
    REFERENCES course (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE CASCADE ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS course_search_index_fts_idx
  ON course_search_index USING gin(document);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_search_index_topics_idx
  ON course_search_index USING gin(topics);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_search_index_user_id_idx
  ON course_search_index (user_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_search_index_advanced_at_idx
  ON course_search_index (advanced_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_search_index_apple_count_idx
  ON course_search_index (apple_count);
CREATE INDEX
CREATE INDEX IF NOT EXISTS course_search_index_lesson_count_idx
  ON course_search_index (lesson_count);
CREATE INDEX
CREATE OR REPLACE FUNCTION course_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    INSERT INTO course_search_index(
      created_at,
      description,
      document,
      id,
      name,
      name_tokens,
      number,
      status,
      study_id,
      topics,
      updated_at,
      user_id
    ) VALUES (
      NEW.created_at,
      NEW.description,
      setweight(to_tsvector('simple', NEW.name_tokens), 'A') ||
      setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B'),
      NEW.id,
      NEW.name,
      NEW.name_tokens,
      NEW.number,
      NEW.status,
      NEW.study_id,
      setweight(to_tsvector('simple', ''), 'A'),
      NEW.updated_at,
      NEW.user_id
    );
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course'
    AND trigger_name = 'after_course_insert'
) THEN
  CREATE TRIGGER after_course_insert
    AFTER INSERT ON course
    FOR EACH ROW EXECUTE PROCEDURE course_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION course_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.name != OLD.name OR NEW.description != OLD.description THEN
      doc = setweight(to_tsvector('simple', NEW.name_tokens), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B');
    ELSE
      doc = (SELECT document FROM course_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE course_search_index
    SET 
      advanced_at = NEW.advanced_at,
      completed_at = NEW.completed_at,
      description = NEW.description,
      document = doc,
      name = NEW.name,
      name_tokens = NEW.name_tokens,
      status = NEW.status,
      updated_at = NEW.updated_at
    WHERE id = NEW.id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course'
    AND trigger_name = 'after_course_update'
) THEN
  CREATE TRIGGER after_course_update
    AFTER UPDATE ON course
    FOR EACH ROW EXECUTE PROCEDURE course_updated();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_course_search_index_lesson_count(_course_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE course_search_index
  SET lesson_count = (
    SELECT count(course_lesson) lesson_count 
    FROM course_lesson
    WHERE course_lesson.course_id = _course_id
  )
  WHERE id = _course_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION refresh_course_search_index_apple_count(_course_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE course_search_index
  SET apple_count = (
    SELECT count(appled) apple_count 
    FROM appled
    WHERE appled.appleable_id = _course_id
  )
  WHERE id = _course_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION refresh_course_search_index_topics(_course_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE course_search_index
  SET
    topics = (
      SELECT 
        setweight(to_tsvector('simple', coalesce(string_agg(topic.name_tokens, ' '), '')), 'A')
      FROM course_topiced
      JOIN topic ON topic.id = course_topiced.topic_id
      WHERE course_topiced.topicable_id = _course_id
    )
  WHERE id = _course_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION course_topiced_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_course_search_index_topics(NEW.topicable_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course_topiced'
    AND trigger_name = 'after_course_topiced_insert'
) THEN
  CREATE TRIGGER after_course_topiced_insert
    AFTER INSERT ON course_topiced
    FOR EACH ROW EXECUTE PROCEDURE course_topiced_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION course_topiced_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_course_search_index_topics(OLD.topicable_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course_topiced'
    AND trigger_name = 'after_course_topiced_delete'
) THEN
  CREATE TRIGGER after_course_topiced_delete
    AFTER DELETE ON course_topiced
    FOR EACH ROW EXECUTE PROCEDURE course_topiced_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS study_search_index (
  advanced_at   TIMESTAMPTZ,
  apple_count   BIGINT       NOT NULL DEFAULT 0,
  created_at    TIMESTAMPTZ  NOT NULL,
  description   TEXT,
  document      TSVECTOR     NOT NULL,
  id            VARCHAR(100) PRIMARY KEY,
  lesson_count  BIGINT       NOT NULL DEFAULT 0,
  name          TEXT         NOT NULL CHECK (name ~ '[\w|-]+'),
  name_tokens   TEXT         NOT NULL,
  private       BOOLEAN      DEFAULT FALSE,
  topics        TSVECTOR     NOT NULL,   
  updated_at    TIMESTAMPTZ  NOT NULL,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (id)
    REFERENCES study (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE CASCADE ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS study_search_index_fts_idx
  ON study_search_index USING gin(document);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_topics_idx
  ON study_search_index USING gin(topics);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_advanced_at_idx
  ON study_search_index (advanced_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_created_at_idx
  ON study_search_index (created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_apple_count_idx
  ON study_search_index (apple_count);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_lesson_count_idx
  ON study_search_index (lesson_count);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_user_id_created_at_idx
  ON study_search_index (user_id, created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS study_search_index_user_id_apple_count_idx
  ON study_search_index (user_id, apple_count);
CREATE INDEX
CREATE OR REPLACE FUNCTION study_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    INSERT INTO study_search_index(
      created_at,
      description,
      document,
      id,
      name,
      name_tokens,
      private,
      topics,
      updated_at,
      user_id
    ) VALUES (
      NEW.created_at,
      NEW.description,
      setweight(to_tsvector('simple', NEW.name_tokens), 'A') ||
      setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B'),
      NEW.id,
      NEW.name,
      NEW.name_tokens,
      NEW.private,
      setweight(to_tsvector('simple', ''), 'A'),
      NEW.updated_at,
      NEW.user_id
    );
    PERFORM refresh_user_search_index_study_count(NEW.user_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'study'
    AND trigger_name = 'after_study_insert'
) THEN
  CREATE TRIGGER after_study_insert
    AFTER INSERT ON study
    FOR EACH ROW EXECUTE PROCEDURE study_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION study_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.name != OLD.name OR NEW.description != OLD.description THEN
      doc = setweight(to_tsvector('simple', NEW.name_tokens), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B');
    ELSE
      doc = (SELECT document FROM study_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE study_search_index
    SET 
      advanced_at = NEW.advanced_at,
      description = NEW.description,
      document = doc,
      name = NEW.name,
      name_tokens = NEW.name_tokens,
      private = NEW.private,
      updated_at = NEW.updated_at
    WHERE id = NEW.id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'study'
    AND trigger_name = 'after_study_update'
) THEN
  CREATE TRIGGER after_study_update
    AFTER UPDATE ON study
    FOR EACH ROW EXECUTE PROCEDURE study_updated();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_study_search_index_lesson_count(_study_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE study_search_index
  SET lesson_count = (
    SELECT count(lesson) lesson_count 
    FROM lesson
    WHERE lesson.study_id = _study_id
  )
  WHERE id = _study_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION lesson_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_study_search_index_lesson_count(OLD.study_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson'
    AND trigger_name = 'after_lesson_delete'
) THEN
  CREATE TRIGGER after_lesson_delete
    AFTER DELETE ON lesson
    FOR EACH ROW EXECUTE PROCEDURE lesson_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_study_search_index_apple_count(_study_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE study_search_index
  SET apple_count = (
    SELECT count(appled) apple_count 
    FROM appled
    WHERE appled.appleable_id = _study_id
  )
  WHERE id = _study_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION appled_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_course_search_index_apple_count(NEW.appleable_id);
    PERFORM refresh_study_search_index_apple_count(NEW.appleable_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'appled'
    AND trigger_name = 'after_appled_insert'
) THEN
  CREATE TRIGGER after_appled_insert
    AFTER INSERT ON appled
    FOR EACH ROW EXECUTE PROCEDURE appled_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION appled_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_course_search_index_apple_count(OLD.appleable_id);
    PERFORM refresh_study_search_index_apple_count(OLD.appleable_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'appled'
    AND trigger_name = 'after_appled_delete'
) THEN
  CREATE TRIGGER after_appled_delete
    AFTER DELETE ON appled
    FOR EACH ROW EXECUTE PROCEDURE appled_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_study_search_index_topics(_study_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE study_search_index
  SET
    topics = (
      SELECT 
        setweight(to_tsvector('simple', coalesce(string_agg(topic.name_tokens, ' '), '')), 'A')
      FROM study_topiced
      JOIN topic ON topic.id = study_topiced.topic_id
      WHERE study_topiced.topicable_id = _study_id
    )
  WHERE id = _study_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION study_topiced_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_study_search_index_topics(NEW.topicable_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'study_topiced'
    AND trigger_name = 'after_study_topiced_insert'
) THEN
  CREATE TRIGGER after_study_topiced_insert
    AFTER INSERT ON study_topiced
    FOR EACH ROW EXECUTE PROCEDURE study_topiced_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION study_topiced_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_study_search_index_topics(OLD.topicable_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'study_topiced'
    AND trigger_name = 'after_study_topiced_delete'
) THEN
  CREATE TRIGGER after_study_topiced_delete
    AFTER DELETE ON study_topiced
    FOR EACH ROW EXECUTE PROCEDURE study_topiced_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS lesson_search_index (
  created_at      TIMESTAMPTZ  DEFAULT now(),
  body            TEXT,
  comment_count   BIGINT       NOT NULL DEFAULT 0,
  course_id       VARCHAR(100),
  course_number   INT,
  document        TSVECTOR     NOT NULL,
  id              VARCHAR(100) PRIMARY KEY,
  number          INT          NOT NULL CHECK(number > 0),
  published_at    TIMESTAMPTZ,
  study_id        VARCHAR(100) NOT NULL,    
  title           TEXT         NOT NULL,
  title_tokens    TEXT         NOT NULL,
  updated_at      TIMESTAMPTZ  DEFAULT now(),
  user_id         VARCHAR(100) NOT NULL,
  FOREIGN KEY (course_id)
    REFERENCES course (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (id)
    REFERENCES lesson (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE CASCADE ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS lesson_search_index_fts_idx
  ON lesson_search_index USING gin(document);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_created_at_idx
  ON lesson_search_index (created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_updated_at_idx
  ON lesson_search_index (updated_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_comment_count_idx
  ON lesson_search_index (comment_count);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_course_id_course_number_idx
  ON lesson_search_index (course_id, course_number);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_study_id_created_at_idx
  ON lesson_search_index (study_id, created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_study_id_updated_at_idx
  ON lesson_search_index (study_id, updated_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_study_id_comment_count_idx
  ON lesson_search_index (study_id, comment_count);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_user_id_created_at_idx
  ON lesson_search_index (user_id, created_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_user_id_updated_at_idx
  ON lesson_search_index (user_id, updated_at);
CREATE INDEX
CREATE INDEX IF NOT EXISTS lesson_search_index_user_id_comment_count_idx
  ON lesson_search_index (user_id, comment_count);
CREATE INDEX
CREATE OR REPLACE FUNCTION lesson_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM advance_study(NEW.study_id);
    PERFORM refresh_study_search_index_lesson_count(NEW.study_id);

    INSERT INTO lesson_search_index(
      created_at,
      body,
      document,
      id,
      number,
      study_id,
      title,
      title_tokens,
      updated_at,
      user_id
    ) VALUES (
      NEW.created_at,
      NEW.body,
      setweight(to_tsvector('simple', NEW.title_tokens), 'A') ||
      setweight(to_tsvector('english', coalesce(NEW.body, '')), 'B'),
      NEW.id,
      NEW.number,
      NEW.study_id,
      NEW.title,
      NEW.title_tokens,
      NEW.updated_at,
      NEW.user_id
    );

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson'
    AND trigger_name = 'after_lesson_insert'
) THEN
  CREATE TRIGGER after_lesson_insert
    AFTER INSERT ON lesson
    FOR EACH ROW EXECUTE PROCEDURE lesson_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION lesson_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.title != OLD.title OR NEW.body != OLD.body THEN
      doc = setweight(to_tsvector('simple', NEW.title_tokens), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.body, '')), 'B'); 
    ELSE
      doc = (SELECT document FROM lesson_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE lesson_search_index
    SET 
      document = doc,
      body = NEW.body,
      number = NEW.number,
      published_at = NEW.published_at,
      title = NEW.title,
      title_tokens = NEW.title_tokens,
      updated_at = NEW.updated_at
    WHERE id = NEW.id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson'
    AND trigger_name = 'after_lesson_update'
) THEN
  CREATE TRIGGER after_lesson_update
    AFTER UPDATE ON lesson
    FOR EACH ROW EXECUTE PROCEDURE lesson_updated();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_lesson_search_index_course_info(_lesson_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE lesson_search_index
  SET course_id = course_lesson.course_id,
    course_number = course_lesson.number
  FROM course_lesson
  WHERE lesson_search_index.id = _lesson_id
    AND course_lesson.lesson_id = _lesson_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION course_lesson_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM advance_course(NEW.course_id);
    PERFORM refresh_course_search_index_lesson_count(NEW.course_id);
    PERFORM refresh_lesson_search_index_course_info(NEW.lesson_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course_lesson'
    AND trigger_name = 'after_course_lesson_insert'
) THEN
  CREATE TRIGGER after_course_lesson_insert
    AFTER INSERT ON course_lesson
    FOR EACH ROW EXECUTE PROCEDURE course_lesson_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION course_lesson_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    UPDATE course_lesson
    SET number = number - 1
    WHERE course_id = OLD.course_id AND number > OLD.number;

    PERFORM refresh_course_search_index_lesson_count(OLD.course_id);
    PERFORM refresh_lesson_search_index_course_info(OLD.lesson_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'course_lesson'
    AND trigger_name = 'after_course_lesson_delete'
) THEN
  CREATE TRIGGER after_course_lesson_delete
    AFTER DELETE ON course_lesson
    FOR EACH ROW EXECUTE PROCEDURE course_lesson_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_lesson_search_index_comment_count(_lesson_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE lesson_search_index
  SET comment_count = (
    SELECT count(lesson_comment) comment_count 
    FROM lesson_comment
    WHERE lesson_comment.lesson_id = _lesson_id
  )
  WHERE id = _lesson_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION lesson_comment_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_lesson_search_index_comment_count(NEW.lesson_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_comment'
    AND trigger_name = 'after_lesson_comment_insert'
) THEN
  CREATE TRIGGER after_lesson_comment_insert
    AFTER INSERT ON lesson_comment
    FOR EACH ROW EXECUTE PROCEDURE lesson_comment_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION lesson_comment_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_lesson_search_index_comment_count(OLD.lesson_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'lesson_comment'
    AND trigger_name = 'after_lesson_comment_delete'
) THEN
  CREATE TRIGGER after_lesson_comment_delete
    AFTER DELETE ON lesson_comment
    FOR EACH ROW EXECUTE PROCEDURE lesson_comment_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS topic_search_index (
  created_at    TIMESTAMPTZ  NOT NULL,
  description   TEXT,
  document      TSVECTOR     NOT NULL,
  id            VARCHAR(100) PRIMARY KEY,
  name          VARCHAR(40)  NOT NULL CHECK(name ~ '^[a-zA-Z0-9][a-zA-Z0-9|-]+[a-zA-Z0-9]$'),
  name_tokens   TEXT         NOT NULL,
  topiced_count BIGINT       NOT NULL DEFAULT 0,  
  updated_at    TIMESTAMPTZ  NOT NULL,
  FOREIGN KEY (id)
    REFERENCES topic (id)
    ON UPDATE CASCADE ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS topic_search_index_fts_idx
  ON topic_search_index USING gin(document);
CREATE INDEX
CREATE INDEX IF NOT EXISTS topic_search_index_topiced_count_idx
  ON topic_search_index (topiced_count);
CREATE INDEX
CREATE OR REPLACE FUNCTION topic_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    INSERT INTO topic_search_index(
      created_at,
      description,
      document,
      id,
      name,
      name_tokens,
      updated_at
    ) VALUES (
      NEW.created_at,
      NEW.description,
      setweight(to_tsvector('simple', NEW.name_tokens), 'A') ||
      setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B'),
      NEW.id,
      NEW.name,
      NEW.name_tokens,
      NEW.updated_at
    );

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'topic'
    AND trigger_name = 'after_topic_insert'
) THEN
  CREATE TRIGGER after_topic_insert
    AFTER INSERT ON topic
    FOR EACH ROW EXECUTE PROCEDURE topic_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION topic_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.name != OLD.name OR NEW.description != OLD.description THEN
      doc = setweight(to_tsvector('simple', NEW.name_tokens), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B'); 
    ELSE
      doc = (SELECT document FROM topic_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE topic_search_index
    SET 
      document = doc,
      description = NEW.description,
      name = NEW.name,
      name_tokens = NEW.name_tokens,
      updated_at = NEW.updated_at
    WHERE id = NEW.id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'topic'
    AND trigger_name = 'after_topic_update'
) THEN
  CREATE TRIGGER after_topic_update
    AFTER UPDATE ON topic
    FOR EACH ROW EXECUTE PROCEDURE topic_updated();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION refresh_topic_search_index_topiced_count(_topic_id VARCHAR)
  RETURNS VOID 
  SECURITY DEFINER
  LANGUAGE sql
AS $$
  UPDATE topic_search_index
  SET topiced_count = (
    SELECT count(topiced) topiced_count 
    FROM topiced
    WHERE topiced.topic_id = _topic_id
  )
  WHERE id = _topic_id;
$$;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION topiced_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_topic_search_index_topiced_count(NEW.topic_id);
    PERFORM refresh_course_search_index_topics(NEW.topicable_id);
    PERFORM refresh_study_search_index_topics(NEW.topicable_id);
    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'topiced'
    AND trigger_name = 'after_topiced_insert'
) THEN
  CREATE TRIGGER after_topiced_insert
    AFTER INSERT ON topiced
    FOR EACH ROW EXECUTE PROCEDURE topiced_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION topiced_deleted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM refresh_topic_search_index_topiced_count(OLD.topic_id);
    PERFORM refresh_course_search_index_topics(OLD.topicable_id);
    PERFORM refresh_study_search_index_topics(OLD.topicable_id);
    RETURN OLD;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'topiced'
    AND trigger_name = 'after_topiced_delete'
) THEN
  CREATE TRIGGER after_topiced_delete
    AFTER DELETE ON topiced
    FOR EACH ROW EXECUTE PROCEDURE topiced_deleted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE TABLE IF NOT EXISTS user_asset_search_index (
  asset_id      BIGINT       NOT NULL,
  created_at    TIMESTAMPTZ  NOT NULL,
  document      TSVECTOR     NOT NULL,
  id            VARCHAR(100) PRIMARY KEY,
  key           TEXT         NOT NULL,
  name          TEXT         NOT NULL CHECK(name ~ '[\w|-]+'),
  name_tokens   TEXT         NOT NULL,
  original_name TEXT         NOT NULL, 
  published_at  TIMESTAMPTZ,
  size          BIGINT       NOT NULL,
  study_id      VARCHAR(100) NOT NULL,
  subtype       TEXT         NOT NULL,
  type          TEXT         NOT NULL,
  updated_at    TIMESTAMPTZ  NOT NULL,
  user_id       VARCHAR(100) NOT NULL,
  FOREIGN KEY (asset_id)
    REFERENCES asset (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (id)
    REFERENCES user_asset (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (user_id)
    REFERENCES account (id)
    ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (study_id)
    REFERENCES study (id)
    ON UPDATE CASCADE ON DELETE CASCADE
);
CREATE TABLE
CREATE INDEX IF NOT EXISTS user_asset_search_index_fts_idx
  ON user_asset_search_index USING gin(document);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_asset_search_index_study_id_idx
  ON user_asset_search_index (study_id);
CREATE INDEX
CREATE INDEX IF NOT EXISTS user_asset_search_index_user_id_idx
  ON user_asset_search_index (user_id);
CREATE INDEX
CREATE OR REPLACE FUNCTION user_asset_inserted()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  BEGIN
    INSERT INTO user_asset_search_index(
      asset_id,
      created_at,
      document,
      id,
      key,
      name,
      name_tokens,
      original_name,
      published_at,
      size,
      study_id,
      subtype,
      type,
      updated_at,
      user_id)
    SELECT
      asset.id,
      asset.created_at,
      setweight(to_tsvector('simple', NEW.name_tokens), 'A'),
      NEW.id,
      asset.key,
      NEW.name,
      NEW.name_tokens,
      asset.name,
      NEW.published_at,
      asset.size,
      NEW.study_id,
      asset.subtype,
      asset.type,
      NEW.updated_at,
      NEW.user_id
    FROM asset
    WHERE asset.id = NEW.asset_id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset'
    AND trigger_name = 'after_user_asset_insert'
) THEN
  CREATE TRIGGER after_user_asset_insert
    AFTER INSERT ON user_asset
    FOR EACH ROW EXECUTE PROCEDURE user_asset_inserted();
END IF;
END;
$$ language 'plpgsql';
DO
CREATE OR REPLACE FUNCTION user_asset_updated()
  RETURNS TRIGGER 
  SECURITY DEFINER
  LANGUAGE plpgsql
AS $$
  DECLARE
    doc TSVECTOR;
  BEGIN
    IF NEW.name != OLD.name THEN
      doc = setweight(to_tsvector('simple', NEW.name_tokens), 'A');
    ELSE
      doc = (SELECT document FROM user_asset_search_index WHERE id = NEW.id); 
    END IF;

    UPDATE user_asset_search_index
    SET 
      document = doc,
      name = NEW.name,
      name_tokens = NEW.name_tokens,
      updated_at = NEW.updated_at
    WHERE id = NEW.id;

    RETURN NEW;
  END;
$$;
CREATE FUNCTION
DO $$
BEGIN
IF NOT EXISTS(
  SELECT *
    FROM information_schema.triggers
    WHERE event_object_table = 'user_asset'
    AND trigger_name = 'after_user_asset_update'
) THEN
  CREATE TRIGGER after_user_asset_update
    AFTER UPDATE ON user_asset
    FOR EACH ROW EXECUTE PROCEDURE user_asset_updated();
END IF;
END;
$$ language 'plpgsql';
DO
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT
    FROM pg_catalog.pg_roles
    WHERE rolname = 'client') THEN
    CREATE ROLE client;
  END IF;
END
$$;
DO
GRANT CONNECT ON DATABASE markusninja TO client;
GRANT
GRANT USAGE ON SCHEMA public TO client;
GRANT
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON account TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_profile TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON email TO client;
GRANT
GRANT SELECT ON role TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_role TO client;
GRANT
GRANT SELECT ON user_master TO client;
GRANT
GRANT SELECT ON user_credentials TO client;
GRANT
GRANT SELECT ON permission TO client;
GRANT
GRANT SELECT ON role_permission TO client;
GRANT
GRANT SELECT ON role_permission_master TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON email_verification_token TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON password_reset_token TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON study TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON course TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON course_lesson TO client;
GRANT
GRANT SELECT ON lesson_master TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_comment TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON label TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON labeled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_labeled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_comment_labeled TO client;
GRANT
GRANT SELECT ON labelable_label TO client;
GRANT
GRANT SELECT ON labeled_lesson TO client;
GRANT
GRANT SELECT ON labeled_lesson_comment TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON topic TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON topiced TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON course_topiced TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON study_topiced TO client;
GRANT
GRANT SELECT ON topicable_topic TO client;
GRANT
GRANT SELECT ON topiced_course TO client;
GRANT
GRANT SELECT ON topiced_study TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON asset TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset TO client;
GRANT
GRANT SELECT ON user_asset_master TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON appled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON course_appled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON study_appled TO client;
GRANT
GRANT SELECT ON apple_giver TO client;
GRANT
GRANT SELECT ON appled_course TO client;
GRANT
GRANT SELECT ON appled_study TO client;
GRANT
GRANT SELECT ON reason TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON enrolled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_enrolled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON course_enrolled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON study_enrolled TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_enrolled TO client;
GRANT
GRANT SELECT ON enrollee TO client;
GRANT
GRANT SELECT ON enrolled_lesson TO client;
GRANT
GRANT SELECT ON enrolled_course TO client;
GRANT
GRANT SELECT ON enrolled_study TO client;
GRANT
GRANT SELECT ON enrolled_user TO client;
GRANT
GRANT SELECT ON event_type TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON course_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_comment_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_added_to_course_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_commented_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_labeled_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_referenced_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_removed_from_course_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_renamed_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_unlabeled_event TO client;
GRANT
GRANT SELECT ON lesson_event_master TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON study_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset_comment_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset_commented_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset_referenced_event TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset_renamed_event TO client;
GRANT
GRANT SELECT ON user_asset_event_master TO client;
GRANT
GRANT SELECT ON event_master TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON notification TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON lesson_notification TO client;
GRANT
GRANT SELECT, INSERT, UPDATE, DELETE ON user_asset_notification TO client;
GRANT
GRANT SELECT ON notification_master TO client;
GRANT
GRANT SELECT ON user_search_index TO client;
GRANT
GRANT SELECT ON course_search_index TO client;
GRANT
GRANT SELECT ON study_search_index TO client;
GRANT
GRANT SELECT ON lesson_search_index TO client;
GRANT
GRANT SELECT ON label_search_index TO client;
GRANT
GRANT SELECT ON topic_search_index TO client;
GRANT
GRANT SELECT ON user_asset_search_index TO client;
GRANT
